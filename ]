/*
Raylib example file.
This is an example main file for a simple raylib project.
Use this as a starting point or replace it with your code.

by Jeffery Myers is marked with CC0 1.0. To view a copy of this license, visit https://creativecommons.org/publicdomain/zero/1.0/

*/

#include "raylib.h"

#include "resource_dir.h"	// utility header for SearchAndSetResourceDir

#include <math.h>
#include <stdio.h>
#include <stdlib.h>


#define WIDTH 1280
#define HEIGHT 800

#define CENTROX WIDTH/2
#define CENTROY HEIGHT/2

#define TAM_BAR_X 10
#define TAM_BAR_Y 8

#define BAR_THICKNESS 1

typedef struct {
  float x, y;       // Coordenadas cartesianas calculadas
  unsigned int p;   // Primo
} primePoint;

// Array dinâmico para remover o hard limit
typedef struct {
  primePoint *items;
  int count;
  int capacity;
} primeList;

// typedef struct square {
//   float x;
//   float y;
//   unsigned long long int r;
//   float theta;
// } square;

void cartesian(int*, int*, float, float);
void draw(float, float, float, int, int, int);
void addPrime(primeList*, int);
int nextPrime();

int main ()
{

	// Tell the window to use vsync and work on high DPI displays
	SetConfigFlags(FLAG_VSYNC_HINT | FLAG_WINDOW_HIGHDPI);

	// Create the window and OpenGL context
	InitWindow(WIDTH, HEIGHT, "Primos");

	// Utility function from resource_dir.h to find the resources folder and set it as the current working directory so we can load from it
	SearchAndSetResourceDir("resources");

  unsigned long long int r = 0;
  unsigned long long int theta = 0;

  // Seta câmera da Raylib
  Camera2D camera = {0};
  camera.target = (Vector2){0, 0};
  camera.offset = (Vector2){ CENTROX, CENTROY };
  camera.rotation = 0.0f;
  camera.zoom = 1.0f;


  int centrox = CENTROX;
  int centroy = CENTROY;

  // Inicializa lista de primos
  primeList primes = {0};

  // Encontra primeiros capacity_NUMS primos
	
	// game loop
	while (!WindowShouldClose())		// run the loop until the user presses ESCAPE or presses the Close button on the window
	{
    if (IsKeyDown(KEY_D)) centrox-=5;
    if (IsKeyDown(KEY_A)) centrox+=5;
    if (IsKeyDown(KEY_W)) centroy+=5; 
    if (IsKeyDown(KEY_S)) centroy-=5;
    if (IsKeyPressed(KEY_R)) {
      zoomLocked = 0;
      centrox = CENTROX;
      centroy = CENTROY;
    }

    float mouseWheelMovement = GetMouseWheelMove();
    if (mouseWheelMovement != 0) {
      zoomLocked = 1;
      zoomout -= mouseWheelMovement;
      if (zoomout <= 0) zoomout = 1;
    }

		// drawinghttps://www.google.com/search?q=gh+cli+to+create+project+of+current+code&sourceid=chrome&ie=UTF-8
		BeginDrawing();

		// Setup the back buffer for drawing (clear color and depth buffers)
		ClearBackground(BLACK);


    // Gera outro primo
    int primo = nextPrime();
    addPrime(&primes, primo);

    // Calcula zoom
    if (!zoomLocked) zoomout = primes.items[primes.count].p/350;
    
    // Escreve instruções na tela
    char temp[50];
    sprintf(temp, "Primos calculados: %d", primes.count);
    DrawText(temp, 10, 10, 20, WHITE);
    
    sprintf(temp, "Primo atual: %d", primes.items[primes.count-1].p);
    DrawText(temp, 10, 30, 20, WHITE);

    sprintf(temp, "Use o scroll para ajustar o zoom");
    DrawText(temp, 10, 50, 20, WHITE);

    sprintf(temp, "WASD para ajustar a câmera");
    DrawText(temp, 10, 70, 20, WHITE);

    sprintf(temp, "Aperte R para resetar a câmera");
    DrawText(temp, 10, 90, 20, WHITE);

    if (zoomout <= 0) zoomout = 1;
    int pointsize = 1/(zoomout/12);
    if (pointsize < 1) pointsize = 1;

    for (int i = 0; i < primes.count; i++){
      DrawCircle(primes.items[i].x + centrox, primes.items[i].y + centroy, pointsize, RED);
    }


    // for (int i = 0; i < quantPrimos; i++){
    //   draw(Numeros[i].r, Numeros[i].theta, zoomout, quantPrimos, centrox, centroy);
    // }



    // Desenha cursor no centro da tela
    DrawRectangle(CENTROX-(TAM_BAR_X/2), CENTROY, TAM_BAR_X, BAR_THICKNESS, WHITE);
    DrawRectangle(CENTROX, CENTROY-(TAM_BAR_Y/2), BAR_THICKNESS, TAM_BAR_Y, WHITE);



		// end the frame and get ready for the next one  (display frame, poll input, etc...)
		EndDrawing();
	}

	// cleanup
	// unload our texture so it can be cleaned up
	// UnloadTexture(wabbit);

	// destroy the window and cleanup the OpenGL context
	CloseWindow();
	return 0;
}

void draw(float r, float theta, float zoomout, int quantPrimos, int centrox, int centroy){
  int x = 0;
  int y = 0;

  char temp[50];
  sprintf(temp, "Primos calculados: %d", quantPrimos);
  DrawText(temp, 10, 10, 20, WHITE);
  
  sprintf(temp, "Primo atual: %d", r);
  DrawText(temp, 10, 30, 20, WHITE);

  sprintf(temp, "Use o scroll para ajustar o zoom", r);
  DrawText(temp, 10, 50, 20, WHITE);

  sprintf(temp, "WASD para ajustar a câmera", r);
  DrawText(temp, 10, 70, 20, WHITE);

  sprintf(temp, "Aperte R para resetar a câmera", r);
  DrawText(temp, 10, 90, 20, WHITE);

  if (zoomout <= 0) zoomout = 1;

  cartesian(&x, &y, r/zoomout, theta);

  int pointsize = 1/(zoomout/12);
  if (pointsize < 1) pointsize = 1;
  DrawCircle(x+centrox, y+centroy, pointsize, RED);
}

void cartesian(int* x, int* y, float r, float theta){
  *x = r * cos(theta);
  *y = -r * sin(theta);
  return;
}

int nextPrime(){
  static int prime = 1;
  int test = prime;

  // Testa números até achar outro primo
  while (true) {
    test++;
    int isPrime = 1;
    int raiz = ceil(sqrt(test));

    for (int divisor = 2; divisor <= raiz; divisor++){
      if (test % divisor == 0 && test != divisor) {
        isPrime = 0;
        break;
      }
    }

    if (isPrime) {
      prime = test;
      return prime;
    }
  }
}

void addPrime(primeList *list, int p){
  if (list->count >= list->capacity){
    // Se a lista estiver cheia, dobra a capacidade
    list->capacity = (list->capacity == 0) ? 1024 : list->capacity * 2;
    list->items = realloc(list->items, list->capacity * sizeof(primePoint));
  }

  float r = p;
  float theta = p;

  list->items[list->count].x = r * cos(theta);
  list->items[list->count].y = -r * sin(theta);

  list->count++;
}
